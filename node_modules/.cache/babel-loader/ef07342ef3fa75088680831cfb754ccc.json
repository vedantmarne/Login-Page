{"ast":null,"code":"import merge from '../merge';\nimport getThemeValue, { propToStyleFunction } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\n\nfunction objectsHaveSameKeys() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n}\n\nfunction styleFunctionSx(props) {\n  const {\n    sx,\n    theme = {}\n  } = props || {};\n\n  if (!sx) {\n    return null; // emotion & styled-components will neglect null\n  }\n  /*\n   * Receive `sxInput` as object or callback\n   * and then recursively check keys & values to create media query object styles.\n   * (the result will be used in `styled`)\n   */\n\n\n  function traverse(sxInput) {\n    let sxObject = sxInput;\n\n    if (typeof sxInput === 'function') {\n      sxObject = sxInput(theme);\n    } else if (typeof sxInput !== 'object') {\n      // value\n      return sxInput;\n    }\n\n    const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n    const breakpointsKeys = Object.keys(emptyBreakpoints);\n    let css = emptyBreakpoints;\n    Object.keys(sxObject).forEach(styleKey => {\n      const value = callIfFn(sxObject[styleKey], theme);\n\n      if (value !== null && value !== undefined) {\n        if (typeof value === 'object') {\n          if (propToStyleFunction[styleKey]) {\n            css = merge(css, getThemeValue(styleKey, value, theme));\n          } else {\n            const breakpointsValues = handleBreakpoints({\n              theme\n            }, value, x => ({\n              [styleKey]: x\n            }));\n\n            if (objectsHaveSameKeys(breakpointsValues, value)) {\n              css[styleKey] = styleFunctionSx({\n                sx: value,\n                theme\n              });\n            } else {\n              css = merge(css, breakpointsValues);\n            }\n          }\n        } else {\n          css = merge(css, getThemeValue(styleKey, value, theme));\n        }\n      }\n    });\n    return removeUnusedBreakpoints(breakpointsKeys, css);\n  }\n\n  return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n}\n\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;","map":{"version":3,"names":["merge","getThemeValue","propToStyleFunction","handleBreakpoints","createEmptyBreakpointObject","removeUnusedBreakpoints","objectsHaveSameKeys","objects","allKeys","reduce","keys","object","concat","Object","union","Set","every","size","length","callIfFn","maybeFn","arg","styleFunctionSx","props","sx","theme","traverse","sxInput","sxObject","emptyBreakpoints","breakpoints","breakpointsKeys","css","forEach","styleKey","value","undefined","breakpointsValues","x","Array","isArray","map","filterProps"],"sources":["E:/test projects/testpro/my-cart-ui (1)/node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js"],"sourcesContent":["import merge from '../merge';\nimport getThemeValue, { propToStyleFunction } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\n\nfunction objectsHaveSameKeys(...objects) {\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n}\n\nfunction styleFunctionSx(props) {\n  const {\n    sx,\n    theme = {}\n  } = props || {};\n\n  if (!sx) {\n    return null; // emotion & styled-components will neglect null\n  }\n  /*\n   * Receive `sxInput` as object or callback\n   * and then recursively check keys & values to create media query object styles.\n   * (the result will be used in `styled`)\n   */\n\n\n  function traverse(sxInput) {\n    let sxObject = sxInput;\n\n    if (typeof sxInput === 'function') {\n      sxObject = sxInput(theme);\n    } else if (typeof sxInput !== 'object') {\n      // value\n      return sxInput;\n    }\n\n    const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n    const breakpointsKeys = Object.keys(emptyBreakpoints);\n    let css = emptyBreakpoints;\n    Object.keys(sxObject).forEach(styleKey => {\n      const value = callIfFn(sxObject[styleKey], theme);\n\n      if (value !== null && value !== undefined) {\n        if (typeof value === 'object') {\n          if (propToStyleFunction[styleKey]) {\n            css = merge(css, getThemeValue(styleKey, value, theme));\n          } else {\n            const breakpointsValues = handleBreakpoints({\n              theme\n            }, value, x => ({\n              [styleKey]: x\n            }));\n\n            if (objectsHaveSameKeys(breakpointsValues, value)) {\n              css[styleKey] = styleFunctionSx({\n                sx: value,\n                theme\n              });\n            } else {\n              css = merge(css, breakpointsValues);\n            }\n          }\n        } else {\n          css = merge(css, getThemeValue(styleKey, value, theme));\n        }\n      }\n    });\n    return removeUnusedBreakpoints(breakpointsKeys, css);\n  }\n\n  return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n}\n\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;"],"mappings":"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"},"metadata":{},"sourceType":"module"}